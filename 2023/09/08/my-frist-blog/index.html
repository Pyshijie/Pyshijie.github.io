<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>my frist blog | Hackery的笔记屋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="JUC大神 Doug Lea （道格.利）  大神放心中，JUC自然神(#^.^#) 为什么多线程极其重要？硬件方面 摩尔定律失效   摩尔定律：它是由英特尔创始人之一Gordon Moore(戈登·摩尔)提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭">
<meta property="og:type" content="article">
<meta property="og:title" content="my frist blog">
<meta property="og:url" content="http://example.com/2023/09/08/my-frist-blog/index.html">
<meta property="og:site_name" content="Hackery的笔记屋">
<meta property="og:description" content="JUC大神 Doug Lea （道格.利）  大神放心中，JUC自然神(#^.^#) 为什么多线程极其重要？硬件方面 摩尔定律失效   摩尔定律：它是由英特尔创始人之一Gordon Moore(戈登·摩尔)提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:\programe-demos\Blog\source_posts\image-20230425140931345.png">
<meta property="og:image" content="d:\programe-demos\Blog\source_posts\image-20230425142235765.png">
<meta property="og:image" content="d:\programe-demos\Blog\source_posts\image-20230425142640851.png">
<meta property="og:image" content="d:\programe-demos\Blog\source_posts\image-20230425142738815.png">
<meta property="og:image" content="d:\programe-demos\Blog\source_posts\image-20230425142747437.png">
<meta property="og:image" content="d:\programe-demos\Blog\source_posts\image-20230425143046404.png">
<meta property="og:image" content="d:\programe-demos\Blog\source_posts\image-20230425143345604.png">
<meta property="og:image" content="d:\programe-demos\Blog\source_posts\image-20230425144222058.png">
<meta property="og:image" content="d:\programe-demos\Blog\source_posts\image-20230425144359357.png">
<meta property="article:published_time" content="2023-09-08T03:42:40.000Z">
<meta property="article:modified_time" content="2023-09-08T03:44:08.179Z">
<meta property="article:author" content="Hackery">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:\programe-demos\Blog\source_posts\image-20230425140931345.png">
  
    <link rel="alternate" href="/atom.xml" title="Hackery的笔记屋" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hackery的笔记屋</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-my-frist-blog" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/08/my-frist-blog/" class="article-date">
  <time class="dt-published" datetime="2023-09-08T03:42:40.000Z" itemprop="datePublished">2023-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      my frist blog
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>JUC大神</p>
<p><strong>Doug Lea （道格.利）</strong></p>
<p><img src="D:\programe-demos\Blog\source_posts\image-20230425140931345.png" alt="image-20230425140931345"></p>
<p>大神放心中，JUC自然神(#^.^#)</p>
<h1 id="为什么多线程极其重要？"><a href="#为什么多线程极其重要？" class="headerlink" title="为什么多线程极其重要？"></a><strong>为什么多线程极其重要？</strong></h1><h2 id="硬件方面"><a href="#硬件方面" class="headerlink" title="硬件方面"></a>硬件方面</h2><ul>
<li>摩尔定律失效</li>
</ul>
<blockquote>
<p>摩尔定律：<br>它是由英特尔创始人之一Gordon Moore(戈登·摩尔)提出来的。其内容为：<br>当价格不变时，集成电路上可容纳的元器件的数目约每隔18-24个月便会增加一倍，性能也将提升一倍。<br>换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度。</p>
<p>可是从2003年开始CPU主频已经不再翻倍，而是采用多核而不是更快的主频。</p>
<p>摩尔定律失效。</p>
<p>在主频不再提高且核数在不断增加的情况下，要想让程序更快就要用到并行或并发编程。</p>
</blockquote>
<h2 id="软件方面"><a href="#软件方面" class="headerlink" title="软件方面"></a>软件方面</h2><p><strong>高并发系统，异步+回调等生产需求</strong></p>
<h1 id="从start一个线程说起"><a href="#从start一个线程说起" class="headerlink" title="从start一个线程说起"></a><strong>从start一个线程说起</strong></h1><h2 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">     * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>start()源码如上图所示。发现其中有一个核心的调用 start0()</p>
<h2 id="start0"><a href="#start0" class="headerlink" title="start0()"></a>start0()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>start0()是一个native方法，我们知道Java底层是C++语言，因此native表示JVM调用底层的c++语言编写的程序。</p>
<p>关于更底层的查看，我们需要下载 OpenJDK源码来查看，官网地址：<a target="_blank" rel="noopener" href="http://openjdk.java.net/">http://openjdk.java.net/</a> </p>
<p>github地址：<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk">https://github.com/openjdk/jdk</a></p>
<p>下载源码到本地，保存在 openjdk目录中。</p>
<p><img src="D:\programe-demos\Blog\source_posts\image-20230425142235765.png" alt="image-20230425142235765"></p>
<ul>
<li>D:\framework-source\java\openjdk\jdk\src\share\native\java\lang\Thread.c</li>
</ul>
<p><img src="D:\programe-demos\Blog\source_posts\image-20230425142640851.png" alt="image-20230425142640851"></p>
<p> java线程是通过start的方法启动执行的，主要内容在native方法start0中，Openjdk的写JNI一般是一一对应的，Thread.java对应的就是Thread.c start0其实就是JVM_StartThread。此时查看源代码可以看到在jvm.h中找到了声明，jvm.cpp中有实现。</p>
<ul>
<li>D:\framework-source\java\openjdk\hotspot\src\share\vm\prims\jvm.cpp</li>
</ul>
<p><img src="D:\programe-demos\Blog\source_posts\image-20230425142738815.png" alt="image-20230425142738815"></p>
<p><img src="D:\programe-demos\Blog\source_posts\image-20230425142747437.png" alt="image-20230425142747437"></p>
<p>观看JVM的源码，我们发现是JVM调用了一个start(native_thread)启动了一个线程，而这个方法的实现在如下：</p>
<ul>
<li>D:\framework-source\java\openjdk\hotspot\src\share\vm\runtime\thread.cpp</li>
</ul>
<p><img src="D:\programe-demos\Blog\source_posts\image-20230425143046404.png" alt="image-20230425143046404"></p>
<p>发现底层是通过操作系统来开启了一个线程。</p>
<h1 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源，⼀个进程会有1个或多个线程的</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在同⼀个进程内⼜可以执⾏多个任务，⽽这每⼀个任务我们就可以看做是⼀个线程</p>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>Monitor(监视器)，也就是我们平时所说的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。</span><br><span class="line"> </span><br><span class="line">JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，</span><br><span class="line"> <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (o)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line">Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。</span><br></pre></td></tr></table></figure>

<p>JVM中明确指出了管程的概念。</p>
<p><img src="D:\programe-demos\Blog\source_posts\image-20230425143345604.png" alt="image-20230425143345604"></p>
<h2 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h2><h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><p>Java线程分为用户线程和守护线程，线程的daemon属性为true表示是守护线程，false表示是用户线程</p>
<p>默认我们开启的都是用户线程，用户线程用来完成这个程序需要完成的业务操作。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>守护线程是一种特殊的线程，顾名思义，守护线程是一种守护的线程，服务的线程，守护线程就是给用户线程提供服务的，如果当前用户线程已经全部执行完毕了，也就是需要完成的业务操作已经执行完毕了，那么JVM会自动退出（不需要再为用户线程提供服务了），所以当系统只剩下守护线程的时候，java虚拟机会自动退出。<strong>典型的守护线程就是我们的GC垃圾回收线程</strong></p>
<p>设置为守护线程，需要在开启线程之前进行设置，setDaemon()方法。</p>
<p><strong>当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出</strong></p>
<p><strong>如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以当系统只剩下守护线程的时候，java虚拟机会自动退出</strong></p>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程开始...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在运行.. 是否是守护线程?&quot;</span></span><br><span class="line">        + (Thread.currentThread().isDaemon() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;不是&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>) ;&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程执行结束...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="D:\programe-demos\Blog\source_posts\image-20230425144222058.png" alt="image-20230425144222058"></p>
<p>当我们不设置t1为守护线程的时候，t1会一直在执行，虽然main已经执行结束了，但是程序仍然不会停止，因为t1还在运行。</p>
<p>当我们设置t1为守护线程时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程开始...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在运行.. 是否是守护线程?&quot;</span></span><br><span class="line">        + (Thread.currentThread().isDaemon() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;不是&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>) ;&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程执行结束...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="D:\programe-demos\Blog\source_posts\image-20230425144359357.png" alt="image-20230425144359357"></p>
<p>当我们设置t1为守护线程的时候，此时t1是守护线程，当main线程执行结束后，也就是说当前所有的用户线程都执行完毕了，jvm自动结束运行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/08/my-frist-blog/" data-id="clma1zuvd000198i9cyr9a2tp" data-title="my frist blog" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/09/08/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/08/my-frist-blog/">my frist blog</a>
          </li>
        
          <li>
            <a href="/2023/09/08/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Hackery<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>