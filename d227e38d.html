<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>索引的创建与设计原则 | Hackery的笔记屋</title><meta name="author" content="Hackery"><meta name="copyright" content="Hackery"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 索引的声明与使用1.1 索引的分类MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。 从 功能逻辑 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。  按照 物理实现方式 ，索引可以分为 2 种：聚簇索引和非聚簇索引。  按照 作用字段个数 进行划分，分成单列索引和联合索引。 1. 普通索引  2. 唯一性索引  3. 主键索引  4">
<meta property="og:type" content="article">
<meta property="og:title" content="索引的创建与设计原则">
<meta property="og:url" content="http://example.com/d227e38d.html">
<meta property="og:site_name" content="Hackery的笔记屋">
<meta property="og:description" content="1. 索引的声明与使用1.1 索引的分类MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。 从 功能逻辑 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。  按照 物理实现方式 ，索引可以分为 2 种：聚簇索引和非聚簇索引。  按照 作用字段个数 进行划分，分成单列索引和联合索引。 1. 普通索引  2. 唯一性索引  3. 主键索引  4">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/medias/bg4.webp">
<meta property="article:published_time" content="2023-11-11T10:08:56.000Z">
<meta property="article:modified_time" content="2023-11-11T10:43:54.346Z">
<meta property="article:author" content="Hackery">
<meta property="article:tag" content="SQL">
<meta property="article:tag" content="索引">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/medias/bg4.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/d227e38d.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Hackery","link":"链接: ","source":"来源: Hackery的笔记屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '索引的创建与设计原则',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-11 18:43:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/profile.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 笔记屋</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/medias/bg4.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Hackery的笔记屋"><span class="site-name">Hackery的笔记屋</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 笔记屋</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">索引的创建与设计原则</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-11T10:08:56.000Z" title="发表于 2023-11-11 18:08:56">2023-11-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-11T10:43:54.346Z" title="更新于 2023-11-11 18:43:54">2023-11-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SQL/">SQL</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SQL/%E5%8E%9F%E5%88%99/">原则</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="索引的创建与设计原则"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1. 索引的声明与使用"></a>1. 索引的声明与使用</h2><h3 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a>1.1 索引的分类</h3><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p>
<p>从 功能逻辑 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。 </p>
<p>按照 物理实现方式 ，索引可以分为 2 种：聚簇索引和非聚簇索引。 </p>
<p>按照 作用字段个数 进行划分，分成单列索引和联合索引。</p>
<p><strong>1. 普通索引</strong></p>
<p><img src="../images/mysql/image-20220621202759576.png" alt="image-20220621202759576" style="float:left;"></p>
<p><strong>2. 唯一性索引</strong></p>
<p><img src="../images/mysql/image-20220621202850551.png" alt="image-20220621202850551" style="float:left;"></p>
<p><strong>3. 主键索引</strong></p>
<p><img src="../images/mysql/image-20220621203302303.png" alt="image-20220621203302303" style="float:left;"></p>
<p><strong>4. 单列索引</strong></p>
<p><img src="../images/mysql/image-20220621203333925.png" alt="image-20220621203333925" style="float:left;"></p>
<p><strong>5. 多列 (组合、联合) 索引</strong></p>
<p><img src="../images/mysql/image-20220621203454424.png" alt="image-20220621203454424" style="float:left;"></p>
<p>我来解释一下为什么，因为联合索引，建立的B+树中，记录之间首先会按照id的值进行一个升序，如果id值相同了，再按照name来排序，如果name也相同了，那么会按照gender进行一个，如果在使用联合索引的时候，不遵循最左前缀的原则的话，那么是找不到的，比如联合索引是idx_id_name_gender，按照name进行查找的话，由于B+树建立是按照id，name和gender的顺序来建立，因此没有id的话，是无法定位到哪条记录的，也就是该索引就失效了，需要进行全表扫描，效率很低。</p>
<p><strong>6. 全文检索</strong></p>
<p><img src="../images/mysql/image-20220621203645789.png" alt="image-20220621203645789" style="float:left;"></p>
<p><strong>7. 补充：空间索引</strong></p>
<p><img src="../images/mysql/image-20220621203736098.png" alt="image-20220621203736098" style="float:left;"></p>
<p><strong>小结：不同的存储引擎支持的索引类型也不一样 </strong></p>
<p>InnoDB ：支持 B-tree、Full-text 等索引，不支持 Hash 索引； </p>
<p>MyISAM ： 支持 B-tree、Full-text 等索引，不支持 Hash 索引； </p>
<p>Memory ：支持 B-tree、Hash 等 索引，不支持 Full-text 索引；</p>
<p>NDB ：支持 Hash 索引，不支持 B-tree、Full-text 等索引； </p>
<p>Archive ：不支 持 B-tree、Hash、Full-text 等索引；</p>
<h3 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a>1.2 创建索引</h3><p>MySQL支持多种方法在单个或多个列上创建索引：在创建表的定义语句 CREATE TABLE 中指定索引列，使用 ALTER TABLE 语句在存在的表上创建索引，或者使用 CREATE INDEX 语句在已存在的表上添加索引。</p>
<h4 id="1-创建表的时候创建索引"><a href="#1-创建表的时候创建索引" class="headerlink" title="1. 创建表的时候创建索引"></a>1. 创建表的时候创建索引</h4><p>使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE dept(</span><br><span class="line">dept_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">dept_name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">emp_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">emp_name VARCHAR(20) UNIQUE,</span><br><span class="line">dept_id INT,</span><br><span class="line">CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>但是，如果显式创建表时创建索引的话，基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name [col_name data_type]</span><br><span class="line">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC |</span><br><span class="line">DESC]</span><br></pre></td></tr></table></figure>
<ul>
<li>UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引； </li>
<li>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建普通索引； </li>
<li>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名； </li>
<li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； </li>
<li>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； </li>
<li>ASC 或 DESC 指定升序或者降序的索引值存储。</li>
</ul>
<p><strong>1. 创建普通索引</strong></p>
<p>在book表中的year_publication字段上建立普通索引，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE book(</span><br><span class="line">book_id INT ,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">authors VARCHAR(100),</span><br><span class="line">info VARCHAR(100) ,</span><br><span class="line">comment VARCHAR(100),</span><br><span class="line">year_publication YEAR,</span><br><span class="line">INDEX(year_publication)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>2. 创建唯一索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test1(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name varchar(30) NOT NULL,</span><br><span class="line">UNIQUE INDEX uk_idx_id(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test1 \G</span><br></pre></td></tr></table></figure>
<p><strong>3. 主键索引</strong></p>
<p>设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法：</p>
<ul>
<li>随表一起建索引：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">id INT(10) UNSIGNED AUTO_INCREMENT ,</span><br><span class="line">student_no VARCHAR(200),</span><br><span class="line">student_name VARCHAR(200),</span><br><span class="line">PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>删除主键索引：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">drop PRIMARY KEY;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引</li>
</ul>
<p><strong>4. 创建单列索引</strong></p>
<p>引举:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test2(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name CHAR(50) NULL,</span><br><span class="line">INDEX single_idx_name(name(20))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test2 \G</span><br></pre></td></tr></table></figure>
<p><strong>5. 创建组合索引</strong></p>
<p>举例：创建表test3，在表中的id、name和age字段上建立组合索引，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test3(</span><br><span class="line">id INT(11) NOT NULL,</span><br><span class="line">name CHAR(30) NOT NULL,</span><br><span class="line">age INT(11) NOT NULL,</span><br><span class="line">info VARCHAR(255),</span><br><span class="line">INDEX multi_idx(id,name,age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>该语句执行完毕之后，使用SHOW INDEX 查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test3 \G</span><br></pre></td></tr></table></figure>
<p>在test3表中，查询id和name字段，使用EXPLAIN语句查看索引的使用情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test3 WHERE id=1 AND name=&#x27;songhongkang&#x27; \G</span><br></pre></td></tr></table></figure>
<p>可以看到，查询id和name字段时，使用了名称为MultiIdx的索引，如果查询 (name, age) 组合或者单独查询name和age字段，会发现结果中possible_keys和key值为NULL, 并没有使用在t3表中创建的索引进行查询，这是因为不满足最左前缀匹配原则。</p>
<p><strong>6. 创建全文索引</strong></p>
<p>FULLTEXT全文索引可以用于全文检索，并且只为 <code>CHAR</code> 、<code>VARCHAR</code> 和 <code>TEXT</code> 列创建索引。索引总是对整个列进行，不支持局部 (前缀) 索引。</p>
<p>举例1：创建表test4，在表中的info字段上建立全文索引，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test4(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name CHAR(30) NOT NULL,</span><br><span class="line">age INT NOT NULL,</span><br><span class="line">info VARCHAR(255),</span><br><span class="line">FULLTEXT INDEX futxt_idx_info(info)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。</p>
</blockquote>
<p>语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test4 \G</span><br></pre></td></tr></table></figure>
<p>由结果可以看到，info字段上已经成功建立了一个名为futxt_idx_info的FULLTEXT索引。</p>
<p>举例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE articles (</span><br><span class="line">id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">title VARCHAR (200),</span><br><span class="line">body TEXT,</span><br><span class="line">FULLTEXT index (title, body)</span><br><span class="line">) ENGINE = INNODB;</span><br></pre></td></tr></table></figure>
<p>创建了一个给title和body字段添加全文索引的表。</p>
<p>举例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `papers` (</span><br><span class="line">`id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">`title` varchar(200) DEFAULT NULL,</span><br><span class="line">`content` text,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">FULLTEXT KEY `title` (`title`,`content`)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p>不同于like方式的的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’;</span><br></pre></td></tr></table></figure>
<p>全文索引用match+against方式查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);</span><br></pre></td></tr></table></figure>
<p>明显的提高查询效率。</p>
<blockquote>
<p>注意点 </p>
<ol>
<li>使用全文索引前，搞清楚版本支持情况； </li>
<li>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</li>
<li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</li>
</ol>
</blockquote>
<p><strong>7. 创建空间索引</strong></p>
<p>空间索引创建中，要求空间类型的字段必须为 非空 。</p>
<p>举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test5(</span><br><span class="line">geo GEOMETRY NOT NULL,</span><br><span class="line">SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>
<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test5 \G</span><br></pre></td></tr></table></figure>
<p>可以看到，test5表的geo字段上创建了名称为spa_idx_geo的空间索引。注意创建时指定空间类型字段值的非空约束，并且表的存储引擎为MyISAM。</p>
<h4 id="2-在已经存在的表上创建索引"><a href="#2-在已经存在的表上创建索引" class="headerlink" title="2. 在已经存在的表上创建索引"></a>2. 在已经存在的表上创建索引</h4><p>在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。</p>
<p><strong>1. 使用ALTER TABLE语句创建索引</strong> ALTER TABLE语句创建索引的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]</span><br><span class="line">[index_name] (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure>
<p><strong>2. 使用CREATE INDEX创建索引</strong> CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中， CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name</span><br><span class="line">ON table_name (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure>
<h3 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a>1.3 删除索引</h3><p><strong>1. 使用ALTER TABLE删除索引</strong>  ALTER TABLE删除索引的基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure>
<p><strong>2. 使用DROP INDEX语句删除索引</strong> DROP INDEX删除索引的基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示: 删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p>
</blockquote>
<h2 id="2-MySQL8-0索引新特性"><a href="#2-MySQL8-0索引新特性" class="headerlink" title="2. MySQL8.0索引新特性"></a>2. MySQL8.0索引新特性</h2><h3 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a>2.1 支持降序索引</h3><p>降序索引以降序存储键值。虽然在语法上，从MySQL 4版本开始就已经支持降序索引的语法了，但实际上DESC定义是被忽略的，直到MySQL 8.x版本才开始真正支持降序索引 (仅限于InnoDB存储引擎)。</p>
<p>MySQL在8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。</p>
<p>举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));</span><br></pre></td></tr></table></figure>
<p>在MySQL 5.7版本中查看数据表ts1的结构，结果如下:</p>
<p><img src="../images/mysql/image-20220622224124267.png" alt="image-20220622224124267"></p>
<p>从结果可以看出，索引仍然是默认的升序</p>
<p>在MySQL 8.0版本中查看数据表ts1的结构，结果如下：</p>
<p><img src="../images/mysql/image-20220622224205048.png" alt="image-20220622224205048"></p>
<p>从结果可以看出，索引已经是降序了。下面继续测试降序索引在执行计划中的表现。</p>
<p>分别在MySQL 5.7版本和MySQL 8.0版本的数据表ts1中插入800条随机数据，执行语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE ts_insert()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 1;</span><br><span class="line">	WHILE i &lt; 800</span><br><span class="line">	DO</span><br><span class="line">		insert into ts1 select rand()*80000, rand()*80000;</span><br><span class="line">		SET i = i+1;</span><br><span class="line">	END WHILE;</span><br><span class="line">	commit;</span><br><span class="line">END //</span><br><span class="line">DELIMITER;</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line">CALL ts_insert();</span><br></pre></td></tr></table></figure>
<p>在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a, b DESC LIMIT 5;</span><br></pre></td></tr></table></figure>
<p>在MySQL 8.0版本中查看数据表 ts1 的执行计划。</p>
<p>从结果可以看出，修改后MySQL8.0 的执行计划要明显好于MySQL 5.7</p>
<h3 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a>2.2 隐藏索引</h3><p>在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较 大，这种操作就会消耗系统过多的资源，操作成本非常高。</p>
<p>从MySQL 8.x开始支持 隐藏索引（invisible indexes） ，只需要将待删除的索引设置为隐藏索引，使 查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引）， 确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 这种通过先将索引设置为隐藏索 引，再删除索引的方式就是软删除。</p>
<p>同时，如果你想验证某个索引删除之后的 <code>查询性能影响</code>，就可以暂时先隐藏该索引。</p>
<blockquote>
<p>注意：</p>
<p>主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。</p>
</blockquote>
<p>索引默认是可见的，在使用CREATE TABLE, CREATE INDEX 或者 ALTER TABLE 等语句时可以通过 <code>VISIBLE</code>（可见） 或者 <code>INVISIBLE</code>（不可见） 关键词设置索引的可见性。</p>
<p><strong>1. 创建表时直接创建</strong></p>
<p>在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename(</span><br><span class="line">propname1 type1[CONSTRAINT1],</span><br><span class="line">propname2 type2[CONSTRAINT2],</span><br><span class="line">……</span><br><span class="line">propnamen typen,</span><br><span class="line">INDEX [indexname](propname1 [(length)]) INVISIBLE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上述语句比普通索引多了一个关键字INVISIBLE，用来标记索引为不可见索引。</p>
<p><strong>2. 在已经存在的表上创建</strong></p>
<p>可以为已经存在的表设置隐藏索引，其语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexname</span><br><span class="line">ON tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>
<p><strong>3. 通过ALTER TABLE语句创建</strong></p>
<p>语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename</span><br><span class="line">ADD INDEX indexname (propname [(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>
<p><strong>4. 切换索引可见状态</strong></p>
<p>已存在的索引可通过如下语句切换可见状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引</span><br><span class="line">ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引</span><br></pre></td></tr></table></figure>
<p>如果将index_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index_cname索引。</p>
<blockquote>
<p>注意 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。（就是即使索引隐藏了也会继续维护该索引，B+树）</p>
</blockquote>
<p>通过设置隐藏索引的可见性可以查看索引对调优的帮助。</p>
<p><strong>5. 使隐藏索引对查询优化器可见</strong></p>
<p>在MySQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关 (use_invisible_indexes) 来打开某个设置，使隐藏索引对查询优化器可见。如果use_invisible_indexes 设置为off (默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计 划时仍会考虑使用隐藏索引。</p>
<p>（1）在MySQL命令行执行如下命令查看查询优化器的开关设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch \G</span><br></pre></td></tr></table></figure>
<p>在输出的结果信息中找到如下属性配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_invisible_indexes=off</span><br></pre></td></tr></table></figure>
<p>此属性配置值为off，说明隐藏索引默认对查询优化器不可见。</p>
<p>（2）使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session optimizer_switch=&quot;use_invisible_indexes=on&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>SQL语句执行成功，再次查看查询优化器的开关设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@optimizer_switch:</span><br><span class="line">index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_</span><br><span class="line">intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_co</span><br><span class="line">st_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on</span><br><span class="line">,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on</span><br><span class="line">,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_ind</span><br><span class="line">exes=on,skip_scan=on,hash_join=on</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>此时，在输出结果中可以看到如下属性配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_invisible_indexes=on</span><br></pre></td></tr></table></figure>
<p>use_invisible_indexes属性的值为on，说明此时隐藏索引对查询优化器可见。</p>
<p>（3）使用EXPLAIN查看以字段invisible_column作为查询条件时的索引使用情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from classes where cname = &#x27;高一2班&#x27;;</span><br></pre></td></tr></table></figure>
<p>查询优化器会使用隐藏索引来查询数据。</p>
<p>（4）如果需要使隐藏索引对查询优化器不可见，则只需要执行如下命令即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session optimizer_switch=&quot;use_invisible_indexes=off&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>再次查看查询优化器的开关设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch \G</span><br></pre></td></tr></table></figure>
<p>此时，use_invisible_indexes属性的值已经被设置为“off”。</p>
<h2 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3. 索引的设计原则"></a>3. 索引的设计原则</h2><p>为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。<strong>索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。</strong>高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。</p>
<h3 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><p><strong>第1步：创建数据库、创建表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE atguigudb1;</span><br><span class="line">USE atguigudb1;</span><br><span class="line">#1.创建学生表和课程表</span><br><span class="line">CREATE TABLE `student_info` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`student_id` INT NOT NULL ,</span><br><span class="line">`name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">`course_id` INT NOT NULL ,</span><br><span class="line">`class_id` INT(11) DEFAULT NULL,</span><br><span class="line">`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `course` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`course_id` INT NOT NULL ,</span><br><span class="line">`course_name` VARCHAR(40) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p><strong>第2步：创建模拟数据必需的存储函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#函数1：创建随机产生字符串函数</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_string(n INT)</span><br><span class="line">	RETURNS VARCHAR(255) #该函数会返回一个字符串</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE chars_str VARCHAR(100) DEFAULT</span><br><span class="line">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">	DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">    	SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">    	SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    RETURN return_str;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#函数2：创建随机数函数</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;</span><br><span class="line">RETURN i;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>创建函数，假如报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This function has none of DETERMINISTIC......</span><br></pre></td></tr></table></figure>
<p>由于开启过慢查询日志bin-log, 我们就必须为我们的function指定一个参数。</p>
<p>主从复制，主机会将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据。如果使 用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql不开启创建函数设置。</p>
<ul>
<li>查看mysql是否允许创建函数：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;log_bin_trust_function_creators&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>命令开启：允许创建函数设置：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>mysqld重启，上述参数又会消失。永久方法：</p>
<ul>
<li><p>windows下：my.ini[mysqld]加上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_bin_trust_function_creators=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>linux下：/etc/my.cnf下my.cnf[mysqld]加上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_bin_trust_function_creators=1</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>第3步：创建插入模拟数据的存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 存储过程1：创建插入课程表存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_course( max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0; #设置手动提交事务</span><br><span class="line">REPEAT #循环</span><br><span class="line">SET i = i + 1; #赋值</span><br><span class="line">INSERT INTO course (course_id, course_name ) VALUES</span><br><span class="line">(rand_num(10000,10100),rand_string(6));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT; #提交事务</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 存储过程2：创建插入学生信息表存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_stu( max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0; #设置手动提交事务</span><br><span class="line">REPEAT #循环</span><br><span class="line">SET i = i + 1; #赋值</span><br><span class="line">INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES</span><br><span class="line">(rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT; #提交事务</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p><strong>第4步：调用存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL insert_course(100);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL insert_stu(1000000);</span><br></pre></td></tr></table></figure>
<h3 id="3-2-哪些情况适合创建索引"><a href="#3-2-哪些情况适合创建索引" class="headerlink" title="3.2 哪些情况适合创建索引"></a>3.2 哪些情况适合创建索引</h3><h4 id="1-字段的数值有唯一性的限制"><a href="#1-字段的数值有唯一性的限制" class="headerlink" title="1. 字段的数值有唯一性的限制"></a>1. 字段的数值有唯一性的限制</h4><p><img src="../images/mysql/image-20220623154615702.png" alt="image-20220623154615702" style="float:left;"></p>
<blockquote>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba） 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>
</blockquote>
<h4 id="2-频繁作为-WHERE-查询条件的字段"><a href="#2-频繁作为-WHERE-查询条件的字段" class="headerlink" title="2. 频繁作为 WHERE 查询条件的字段"></a>2. 频繁作为 WHERE 查询条件的字段</h4><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在 数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。 </p>
<p>比如student_info数据表（含100万条数据），假设我们想要查询 student_id=123110 的用户信息。</p>
<p>不加 索引的情况下。</p>
<p><img src="Users\Yin&#39;sComputer\Desktop\MySQL\MySQL高级篇\image-20230823103900074.png" alt="image-20230823103900074"></p>
<p>加索引的情况下：<img src="Users\Yin&#39;sComputer\Desktop\MySQL\MySQL高级篇\image-20230823103920447.png" alt="image-20230823103920447"></p>
<h4 id="3-经常-GROUP-BY-和-ORDER-BY-的列"><a href="#3-经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="3. 经常 GROUP BY 和 ORDER BY 的列"></a>3. 经常 GROUP BY 和 ORDER BY 的列</h4><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立组合索引 。</p>
<h4 id="4-UPDATE、DELETE-的-WHERE-条件列"><a href="#4-UPDATE、DELETE-的-WHERE-条件列" class="headerlink" title="4. UPDATE、DELETE 的 WHERE 条件列"></a>4. UPDATE、DELETE 的 WHERE 条件列</h4><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p>
<h4 id="5-DISTINCT-字段需要创建索引"><a href="#5-DISTINCT-字段需要创建索引" class="headerlink" title="5.DISTINCT 字段需要创建索引"></a>5.DISTINCT 字段需要创建索引</h4><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。 </p>
<p>比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行 SQL 语句：</p>
<p><img src="Users\Yin&#39;sComputer\Desktop\MySQL\MySQL高级篇\image-20230823104331407.png" alt="image-20230823104331407"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT(student_id) FROM `student_info`;</span><br></pre></td></tr></table></figure>
<p>运行结果（997287 条记录，运行时间 0.683s ）</p>
<p>如果我们对 student_id 创建索引，再执行 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT(student_id) FROM `student_info`;</span><br></pre></td></tr></table></figure>
<p>运行结果（198890 条记录，运行时间 0.010s ）</p>
<p>你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照递增的顺序 进行展示的。<strong>这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。</strong></p>
<h4 id="6-多表-JOIN-连接操作时，创建索引注意事项"><a href="#6-多表-JOIN-连接操作时，创建索引注意事项" class="headerlink" title="6. 多表 JOIN 连接操作时，创建索引注意事项"></a>6. 多表 JOIN 连接操作时，创建索引注意事项</h4><p>首先， <code>连接表的数量尽量不要超过 3 张</code> ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增 长会非常快，严重影响查询的效率。 </p>
<p>其次， <code>对 WHERE 条件创建索引</code> ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下， 没有 WHERE 条件过滤是非常可怕的。 </p>
<p>最后， <code>对用于连接的字段创建索引</code> ，并且该字段在多张表中的 类型必须一致 。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型，如果类型不一致，可能触发类型转换，导致索引失效。</p>
<p>举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.course_id, name, s.student_id, c.course_name</span><br><span class="line">FROM student_info s JOIN course c</span><br><span class="line">ON s.course_id = c.course_id</span><br><span class="line">WHERE name = &#x27;462eed7ac6e791292a79&#x27;;</span><br></pre></td></tr></table></figure>
<p>运行结果（1 条数据，运行时间 0.189s ）</p>
<p>这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。</p>
<h4 id="7-使用列的类型小的创建索引"><a href="#7-使用列的类型小的创建索引" class="headerlink" title="7. 使用列的类型小的创建索引"></a>7. 使用列的类型小的创建索引</h4><p><img src="../images/mysql/image-20220623175306282.png" alt="image-20220623175306282" style="float:left;"></p>
<h4 id="8-使用字符串前缀创建索引"><a href="#8-使用字符串前缀创建索引" class="headerlink" title="8. 使用字符串前缀创建索引"></a>8. 使用字符串前缀创建索引</h4><p><img src="../images/mysql/image-20220623175513439.png" alt="image-20220623175513439" style="float:left;"></p>
<p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table shop(address varchar(120) not null);</span><br><span class="line">alter table shop add index(address(12));</span><br></pre></td></tr></table></figure>
<p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字 段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？</p>
<p>先看一下字段在全部数据中的选择度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct address) / count(*) from shop</span><br></pre></td></tr></table></figure>
<p>通过不同长度去计算，与全表的选择性对比：</p>
<p>公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count(distinct left(列名, 索引长度))/count(*)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度</span><br><span class="line">count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度</span><br><span class="line">count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度</span><br><span class="line">count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度</span><br><span class="line">from shop;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>越接近于1越好，说明越有区分度</p>
</blockquote>
<p><strong>引申另一个问题：索引列前缀对排序的影响</strong></p>
<p>如果使用了索引列前缀，比方说前边只把address列的 <code>前12个字符</code> 放到了二级索引中，下边这个查询可能就有点尴尬了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM shop</span><br><span class="line">ORDER BY address</span><br><span class="line">LIMIT 12;</span><br></pre></td></tr></table></figure>
<p>因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式 <code>无法支持使用索引排序</code> ，只能使用文件排序。</p>
<p><strong>拓展：Alibaba《Java开发手册》</strong></p>
<p>【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本 区分度决定索引长度。 </p>
<p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p>
<h4 id="9-区分度高-散列性高-的列适合作为索引"><a href="#9-区分度高-散列性高-的列适合作为索引" class="headerlink" title="9. 区分度高(散列性高)的列适合作为索引"></a>9. 区分度高(散列性高)的列适合作为索引</h4><p><code>列的基数</code> 指的是某一列中不重复数据的个数，比方说某个列包含值 <code>2, 5, 8, 2, 5, 8, 2, 5, 8</code>，虽然有<code>9</code>条记录，但该列的基数却是3。也就是说<strong>在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。</strong>这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列的建立索引效果可能不好。</p>
<p>可以使用公式<code>select count(distinct a) / count(*) from t1</code> 计算区分度，越接近1越好，一般超过33%就算比较高效的索引了。</p>
<p>扩展：联合索引把区分度搞(散列性高)的列放在前面（因为联合索引有一个最左匹配原则）。</p>
<h4 id="10-使用最频繁的列放到联合索引的左侧"><a href="#10-使用最频繁的列放到联合索引的左侧" class="headerlink" title="10. 使用最频繁的列放到联合索引的左侧"></a>10. 使用最频繁的列放到联合索引的左侧</h4><p>这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率。</p>
<h4 id="11-在多个字段都要创建索引的情况下，联合索引优于单值索引，主要有一个索引下推的优化"><a href="#11-在多个字段都要创建索引的情况下，联合索引优于单值索引，主要有一个索引下推的优化" class="headerlink" title="11. 在多个字段都要创建索引的情况下，联合索引优于单值索引，主要有一个索引下推的优化"></a>11. 在多个字段都要创建索引的情况下，联合索引优于单值索引，主要有一个索引下推的优化</h4><h3 id="3-3-限制索引的数目"><a href="#3-3-限制索引的数目" class="headerlink" title="3.3 限制索引的数目"></a>3.3 限制索引的数目</h3><p><img src="../images/mysql/image-20220627151947786.png" alt="image-20220627151947786" style="float:left;"></p>
<h3 id="3-4-哪些情况不适合创建索引"><a href="#3-4-哪些情况不适合创建索引" class="headerlink" title="3.4 哪些情况不适合创建索引"></a>3.4 哪些情况不适合创建索引</h3><h4 id="1-在where中使用不到的字段，不要设置索引"><a href="#1-在where中使用不到的字段，不要设置索引" class="headerlink" title="1. 在where中使用不到的字段，不要设置索引"></a>1. 在where中使用不到的字段，不要设置索引</h4><p>WHERE条件 (包括 GROUP BY、ORDER BY) 里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT course_id, student_id, create_time</span><br><span class="line">FROM student_info</span><br><span class="line">WHERE student_id = 41251;</span><br></pre></td></tr></table></figure>
<p>因为我们是按照 student_id 来进行检索的，所以不需要对其他字段创建索引，即使这些字段出现在SELECT字段中。</p>
<h4 id="2-数据量小的表最好不要使用索引"><a href="#2-数据量小的表最好不要使用索引" class="headerlink" title="2. 数据量小的表最好不要使用索引"></a>2. 数据量小的表最好不要使用索引</h4><p>如果表记录太少，比如少于1000个，那么是不需要创建索引的。表记录太少，是否创建索引 <code>对查询效率的影响并不大</code>。甚至说，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</p>
<p>举例：创建表1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t_without_index(</span><br><span class="line">a INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">b INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>提供存储过程1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#创建存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE t_wout_insert()</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 1;</span><br><span class="line">    WHILE i &lt;= 900</span><br><span class="line">    DO</span><br><span class="line">        INSERT INTO t_without_index(b) SELECT RAND()*10000;</span><br><span class="line">        SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    COMMIT;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL t_wout_insert()</span><br></pre></td></tr></table></figure>
<p>创建表2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t_with_index(</span><br><span class="line">a INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">b INT,</span><br><span class="line">INDEX idx_b(b)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>创建存储过程2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#创建存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE t_with_insert()</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 1;</span><br><span class="line">    WHILE i &lt;= 900</span><br><span class="line">    DO</span><br><span class="line">        INSERT INTO t_with_index(b) SELECT RAND()*10000;</span><br><span class="line">        SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    COMMIT;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL t_with_insert();</span><br></pre></td></tr></table></figure>
<p>查询对比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t_without_index where b = 9879;</span><br><span class="line">+------+------+</span><br><span class="line">| a | b |</span><br><span class="line">+------+------+</span><br><span class="line">| 1242 | 9879 |</span><br><span class="line">+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_with_index where b = 9879;</span><br><span class="line">+-----+------+</span><br><span class="line">| a | b |</span><br><span class="line">+-----+------+</span><br><span class="line">| 112 | 9879 |</span><br><span class="line">+-----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>你能看到运行结果相同，但是在数据量不大的情况下，索引就发挥不出作用了。</p>
<blockquote>
<p>结论：在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。</p>
</blockquote>
<h4 id="3-有大量重复数据的列上不要建立索引"><a href="#3-有大量重复数据的列上不要建立索引" class="headerlink" title="3. 有大量重复数据的列上不要建立索引"></a>3. 有大量重复数据的列上不要建立索引</h4><p>在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的”性别”字段上只有“男”与“女”两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会<code>严重降低数据更新速度</code>。</p>
<p>举例1：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先 访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。</p>
<p>举例2：假设有一个学生表，学生总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1。</p>
<p>学生表 student_gender 结构如下。其中数据表中的 student_gender 字段取值为 0 或 1，0 代表女性，1 代表男性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student_gender(</span><br><span class="line">    student_id INT(11) NOT NULL,</span><br><span class="line">    student_name VARCHAR(50) NOT NULL,</span><br><span class="line">    student_gender TINYINT(1) NOT NULL,</span><br><span class="line">    PRIMARY KEY(student_id)</span><br><span class="line">)ENGINE = INNODB;</span><br></pre></td></tr></table></figure>
<p>如果我们要筛选出这个学生表中的男性，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student_gender WHERE student_gender = 1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引。</p>
</blockquote>
<h4 id="4-避免对经常更新的表创建过多的索引"><a href="#4-避免对经常更新的表创建过多的索引" class="headerlink" title="4.  避免对经常更新的表创建过多的索引"></a>4.  避免对经常更新的表创建过多的索引</h4><p>第一层含义：频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。</p>
<p>第二层含义：避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却降低更新表的速度。</p>
<h4 id="5-不建议用无序的值作为索引"><a href="#5-不建议用无序的值作为索引" class="headerlink" title="5. 不建议用无序的值作为索引"></a>5. 不建议用无序的值作为索引</h4><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂，记录转移等)、MD5、HASH、无序长字 符串等。</p>
<h4 id="6-删除不再使用或者很少使用的索引"><a href="#6-删除不再使用或者很少使用的索引" class="headerlink" title="6. 删除不再使用或者很少使用的索引"></a>6. 删除不再使用或者很少使用的索引</h4><p>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p>
<h4 id="7-不要定义夯余或重复的索引"><a href="#7-不要定义夯余或重复的索引" class="headerlink" title="7. 不要定义夯余或重复的索引"></a>7. 不要定义夯余或重复的索引</h4><p>① 冗余索引 </p>
<p>举例：建表语句如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE person_info(</span><br><span class="line">    id INT UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    birthday DATE NOT NULL,</span><br><span class="line">    phone_number CHAR(11) NOT NULL,</span><br><span class="line">    country varchar(100) NOT NULL,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),</span><br><span class="line">    KEY idx_name (name(10))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们知道，通过 idx_name_birthday_phone_number 索引就可以对 name 列进行快速搜索，再创建一 个专门针对 name 列的索引就算是一个 冗余索引 ，维护这个索引只会增加维护的成本，并不会对搜索有 什么好处。</p>
<p>② 重复索引 </p>
<p>另一种情况，我们可能会对某个列 重复建立索引 ，比方说这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE repeat_index_demo (</span><br><span class="line">col1 INT PRIMARY KEY,</span><br><span class="line">col2 INT,</span><br><span class="line">UNIQUE uk_idx_c1 (col1),</span><br><span class="line">INDEX idx_c1 (col1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就 会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p>
<hr>
<blockquote>
<p>备注：</p>
<p>1.上述图片资源均来源自网上，如有侵权请联系，会立即删除</p>
<p>2.此处笔记为学习宋红康老师MySQL时，结合自己理解梳理下来的，如有不对，恳请斧正~</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Hackery</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/d227e38d.html">http://example.com/d227e38d.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hackery的笔记屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SQL/">SQL</a><a class="post-meta__tags" href="/tags/%E7%B4%A2%E5%BC%95/">索引</a></div><div class="post_share"><div class="social-share" data-image="/medias/bg4.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/8356954.html" title="InnoDB底层存储结构"><img class="cover" src="/medias/bg5.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">InnoDB底层存储结构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/c1c058c4.html" title="一条SQL的底层执行过程详解"><img class="cover" src="/medias/bg1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-11</div><div class="title">一条SQL的底层执行过程详解</div></div></a></div><div><a href="/de7a7ce4.html" title="MySQL底层索引数据结构详解"><img class="cover" src="/medias/bg2.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-11</div><div class="title">MySQL底层索引数据结构详解</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/profile.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Hackery</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Pyshijie" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yitshijie001@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">1. 索引的声明与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 索引的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 创建表的时候创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E8%A1%A8%E4%B8%8A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 在已经存在的表上创建索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 删除索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-MySQL8-0%E7%B4%A2%E5%BC%95%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">2. MySQL8.0索引新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%94%AF%E6%8C%81%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 支持降序索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 隐藏索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">3.</span> <span class="toc-text">3. 索引的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 数据准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 哪些情况适合创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%97%E6%AE%B5%E7%9A%84%E6%95%B0%E5%80%BC%E6%9C%89%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">3.2.1.</span> <span class="toc-text">1. 字段的数值有唯一性的限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A2%91%E7%B9%81%E4%BD%9C%E4%B8%BA-WHERE-%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. 频繁作为 WHERE 查询条件的字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%8F%E5%B8%B8-GROUP-BY-%E5%92%8C-ORDER-BY-%E7%9A%84%E5%88%97"><span class="toc-number">3.2.3.</span> <span class="toc-text">3. 经常 GROUP BY 和 ORDER BY 的列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-UPDATE%E3%80%81DELETE-%E7%9A%84-WHERE-%E6%9D%A1%E4%BB%B6%E5%88%97"><span class="toc-number">3.2.4.</span> <span class="toc-text">4. UPDATE、DELETE 的 WHERE 条件列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-DISTINCT-%E5%AD%97%E6%AE%B5%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">3.2.5.</span> <span class="toc-text">5.DISTINCT 字段需要创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A4%9A%E8%A1%A8-JOIN-%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8C%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.2.6.</span> <span class="toc-text">6. 多表 JOIN 连接操作时，创建索引注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BD%BF%E7%94%A8%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%B0%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">3.2.7.</span> <span class="toc-text">7. 使用列的类型小的创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">3.2.8.</span> <span class="toc-text">8. 使用字符串前缀创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%8C%BA%E5%88%86%E5%BA%A6%E9%AB%98-%E6%95%A3%E5%88%97%E6%80%A7%E9%AB%98-%E7%9A%84%E5%88%97%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">3.2.9.</span> <span class="toc-text">9. 区分度高(散列性高)的列适合作为索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E4%BD%BF%E7%94%A8%E6%9C%80%E9%A2%91%E7%B9%81%E7%9A%84%E5%88%97%E6%94%BE%E5%88%B0%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A6%E4%BE%A7"><span class="toc-number">3.2.10.</span> <span class="toc-text">10. 使用最频繁的列放到联合索引的左侧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%9C%A8%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E9%83%BD%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%BC%98%E4%BA%8E%E5%8D%95%E5%80%BC%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%9C%89%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">3.2.11.</span> <span class="toc-text">11. 在多个字段都要创建索引的情况下，联合索引优于单值索引，主要有一个索引下推的优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%99%90%E5%88%B6%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 限制索引的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 哪些情况不适合创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9C%A8where%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%88%B0%E7%9A%84%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%AE%BE%E7%BD%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">3.4.1.</span> <span class="toc-text">1. 在where中使用不到的字段，不要设置索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E9%87%8F%E5%B0%8F%E7%9A%84%E8%A1%A8%E6%9C%80%E5%A5%BD%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">2. 数据量小的表最好不要使用索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9C%89%E5%A4%A7%E9%87%8F%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%97%E4%B8%8A%E4%B8%8D%E8%A6%81%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">3.4.3.</span> <span class="toc-text">3. 有大量重复数据的列上不要建立索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%81%BF%E5%85%8D%E5%AF%B9%E7%BB%8F%E5%B8%B8%E6%9B%B4%E6%96%B0%E7%9A%84%E8%A1%A8%E5%88%9B%E5%BB%BA%E8%BF%87%E5%A4%9A%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">3.4.4.</span> <span class="toc-text">4.  避免对经常更新的表创建过多的索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8%E6%97%A0%E5%BA%8F%E7%9A%84%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">3.4.5.</span> <span class="toc-text">5. 不建议用无序的值作为索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%88%A0%E9%99%A4%E4%B8%8D%E5%86%8D%E4%BD%BF%E7%94%A8%E6%88%96%E8%80%85%E5%BE%88%E5%B0%91%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">3.4.6.</span> <span class="toc-text">6. 删除不再使用或者很少使用的索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%B8%8D%E8%A6%81%E5%AE%9A%E4%B9%89%E5%A4%AF%E4%BD%99%E6%88%96%E9%87%8D%E5%A4%8D%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">3.4.7.</span> <span class="toc-text">7. 不要定义夯余或重复的索引</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/d227e38d.html" title="索引的创建与设计原则"><img src="/medias/bg4.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="索引的创建与设计原则"/></a><div class="content"><a class="title" href="/d227e38d.html" title="索引的创建与设计原则">索引的创建与设计原则</a><time datetime="2023-11-11T10:08:56.000Z" title="发表于 2023-11-11 18:08:56">2023-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/8356954.html" title="InnoDB底层存储结构"><img src="/medias/bg5.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="InnoDB底层存储结构"/></a><div class="content"><a class="title" href="/8356954.html" title="InnoDB底层存储结构">InnoDB底层存储结构</a><time datetime="2023-11-11T10:08:41.000Z" title="发表于 2023-11-11 18:08:41">2023-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/de7a7ce4.html" title="MySQL底层索引数据结构详解"><img src="/medias/bg2.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL底层索引数据结构详解"/></a><div class="content"><a class="title" href="/de7a7ce4.html" title="MySQL底层索引数据结构详解">MySQL底层索引数据结构详解</a><time datetime="2023-11-11T10:08:25.000Z" title="发表于 2023-11-11 18:08:25">2023-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/c1c058c4.html" title="一条SQL的底层执行过程详解"><img src="/medias/bg1.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一条SQL的底层执行过程详解"/></a><div class="content"><a class="title" href="/c1c058c4.html" title="一条SQL的底层执行过程详解">一条SQL的底层执行过程详解</a><time datetime="2023-11-11T10:08:01.000Z" title="发表于 2023-11-11 18:08:01">2023-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/722dc550.html" title="HTTP与HTTPS原理解析"><img src="/medias/bg3.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTTP与HTTPS原理解析"/></a><div class="content"><a class="title" href="/722dc550.html" title="HTTP与HTTPS原理解析">HTTP与HTTPS原理解析</a><time datetime="2023-11-11T10:07:41.000Z" title="发表于 2023-11-11 18:07:41">2023-11-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/medias/bg4.webp')"><div id="footer-wrap"><div class="copyright">&copy;2023 By Hackery</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,  welcome  to  my blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>